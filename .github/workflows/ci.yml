name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      should_version: ${{ steps.filter.outputs.versionable == 'true' || steps.semver.outputs.has_semver == 'true' }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            versionable:
              - 'hooks/**'
              - 'commands/**'
              - 'GitVersion.yml'

      - name: Check for +semver in commit message
        id: semver
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -qE '\+semver:\s*(major|minor|patch|breaking|feature|fix|none|skip)'; then
            echo "has_semver=true" >> $GITHUB_OUTPUT
            echo "Found +semver in commit message"
          else
            echo "has_semver=false" >> $GITHUB_OUTPUT
            echo "No +semver found in commit message"
          fi

  test-linux:
    name: Test on Linux
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov

      - name: Verify Python installation
        run: |
          echo "Python version:"
          python --version
          echo "pytest version:"
          pytest --version

      - name: Run pytest tests
        run: |
          pytest tests/ -v --tb=short

      - name: Test hook directly with sample input
        run: |
          # Create a test directory with protection
          mkdir -p /tmp/test-project
          touch /tmp/test-project/.block

          # Test Edit tool is blocked (check for JSON block decision)
          OUTPUT=$(echo '{"tool_name": "Edit", "tool_input": {"file_path": "/tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' || { echo "Expected block decision for Edit"; exit 1; }
          echo "Edit tool correctly blocked"

          # Test Write tool is blocked
          OUTPUT=$(echo '{"tool_name": "Write", "tool_input": {"file_path": "/tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' || { echo "Expected block decision for Write"; exit 1; }
          echo "Write tool correctly blocked"

          # Test Read tool is allowed (not a modifying operation)
          OUTPUT=$(echo '{"tool_name": "Read", "tool_input": {"file_path": "/tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' && { echo "Read should not be blocked"; exit 1; } || true
          echo "Read tool correctly allowed"

          # Test Bash rm command is blocked
          OUTPUT=$(echo '{"tool_name": "Bash", "tool_input": {"command": "rm /tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' || { echo "Expected block decision for Bash rm"; exit 1; }
          echo "Bash rm correctly blocked"

  test-macos:
    name: Test on macOS
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov

      - name: Verify Python installation
        run: |
          echo "Python version:"
          python --version
          echo "pytest version:"
          pytest --version

      - name: Run pytest tests
        run: |
          pytest tests/ -v --tb=short

  test-windows:
    name: Test on Windows
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov

      - name: Verify Python installation
        run: |
          echo "Python version:"
          python --version
          echo "pytest version:"
          pytest --version

      - name: Run pytest tests (includes hook integration tests)
        run: |
          pytest tests/ -v --tb=short

  lint:
    name: Python Linting and Type Checking
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install linting tools
        run: |
          python -m pip install --upgrade pip
          pip install ruff mypy

      - name: Run ruff linter
        run: |
          ruff check hooks/ tests/

      - name: Run mypy type checker
        run: |
          mypy hooks/protect_directories.py --ignore-missing-imports

  e2e:
    name: E2E - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code CLI
        run: npm install -g @anthropic-ai/claude-code

      - name: Verify Claude Code installation
        run: claude --version

      - name: Make scripts executable (Unix)
        if: runner.os != 'Windows'
        run: chmod +x hooks/*.py

      - name: Verify hook scripts exist
        shell: bash
        run: |
          echo "Verifying hook scripts exist in: ${GITHUB_WORKSPACE}"

          # Check Python script
          if [ -f "hooks/protect_directories.py" ]; then
            echo "Found: hooks/protect_directories.py"
            ls -la hooks/protect_directories.py
          else
            echo "ERROR: Missing hooks/protect_directories.py"
            exit 1
          fi

          # Check polyglot entry point
          if [ -f "hooks/run-hook.cmd" ]; then
            echo "Found: hooks/run-hook.cmd"
          else
            echo "ERROR: Missing hooks/run-hook.cmd"
            exit 1
          fi

          echo ""
          echo "All hook scripts found!"

      - name: Create test project directory
        shell: bash
        run: |
          # Use RUNNER_TEMP for cross-platform compatibility
          E2E_DIR="${RUNNER_TEMP}/e2e-test-project"
          mkdir -p "${E2E_DIR}/protected"
          mkdir -p "${E2E_DIR}/unprotected"

          # Create .block file in protected directory
          echo '{}' > "${E2E_DIR}/protected/.block"

          # Create some test files
          echo "protected content" > "${E2E_DIR}/protected/existing-file.txt"
          echo "unprotected content" > "${E2E_DIR}/unprotected/existing-file.txt"

          # Store path for later steps
          echo "E2E_DIR=${E2E_DIR}" >> $GITHUB_ENV

      - name: Configure Claude Code with plugin hooks (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          # Get the absolute path to the plugin root
          PLUGIN_ROOT="${GITHUB_WORKSPACE}"
          RUN_HOOK_PATH="${PLUGIN_ROOT}/hooks/run-hook.cmd"

          echo "Hook path: $RUN_HOOK_PATH"

          # Verify files exist
          if [ ! -f "$RUN_HOOK_PATH" ]; then
            echo "ERROR: run-hook.cmd not found at $RUN_HOOK_PATH"
            exit 1
          fi

          # Create Claude Code settings directory
          mkdir -p ~/.claude

          # Create settings.json with hooks configuration using polyglot entry point
          cat > ~/.claude/settings.json <<EOF
          {
            "hooks": {
              "PreToolUse": [
                {
                  "matcher": "Edit|Write|NotebookEdit|Bash",
                  "hooks": [
                    {
                      "type": "command",
                      "command": "\"${RUN_HOOK_PATH}\"",
                      "timeout": 5000
                    }
                  ]
                }
              ]
            }
          }
          EOF

          echo ""
          echo "Created Claude Code settings:"
          cat ~/.claude/settings.json

      - name: Configure Claude Code with plugin hooks (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          PLUGIN_ROOT="${GITHUB_WORKSPACE}"
          RUN_HOOK_PATH="${PLUGIN_ROOT}/hooks/run-hook.cmd"

          echo "Hook path (Windows): $RUN_HOOK_PATH"

          # Verify files exist
          if [ ! -f "$RUN_HOOK_PATH" ]; then
            echo "ERROR: run-hook.cmd not found at $RUN_HOOK_PATH"
            exit 1
          fi

          # Create Claude Code settings directory
          mkdir -p ~/.claude

          # Create settings.json with hooks configuration using polyglot entry point
          cat > ~/.claude/settings.json <<EOF
          {
            "hooks": {
              "PreToolUse": [
                {
                  "matcher": "Edit|Write|NotebookEdit|Bash",
                  "hooks": [
                    {
                      "type": "command",
                      "command": "\"${RUN_HOOK_PATH}\"",
                      "timeout": 5000
                    }
                  ]
                }
              ]
            }
          }
          EOF

          echo ""
          echo "Created Claude Code settings (Windows):"
          cat ~/.claude/settings.json

      - name: E2E Test - Protected file write blocked
        shell: bash
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          echo "Testing that protected files cannot be written..."

          cd "${E2E_DIR}"

          # Ask Claude to write to a protected file
          # Note: --allowedTools "Write" allows Claude to attempt the write, so the hook can block it
          set +e
          OUTPUT=$(claude --print "Write the text 'MODIFIED' to the file protected/test-write.txt" --max-turns 3 --allowedTools "Write" 2>&1)
          CLAUDE_EXIT=$?
          set -e

          echo "Claude exit code: $CLAUDE_EXIT"
          echo "Claude output:"
          echo "$OUTPUT"
          echo ""

          # Check if Claude failed unexpectedly (not due to hook blocking)
          if [ $CLAUDE_EXIT -ne 0 ]; then
            echo "Claude exited with code $CLAUDE_EXIT"
            # Only fail if it's not an expected hook block
            if ! echo "$OUTPUT" | grep -qiE "block|protected|\.block"; then
              echo "FAIL: Claude failed unexpectedly (not due to hook blocking)"
              exit 1
            fi
            echo "Claude exit was due to hook blocking (expected)"
          fi

          # Verify hook blocking message appeared in output
          if echo "$OUTPUT" | grep -qiE "block|protected|\.block"; then
            echo "PASS: Hook blocking message detected in output"
          else
            echo "WARNING: No hook blocking message detected in output"
          fi

          # The file should NOT exist (was blocked)
          if [ -f "protected/test-write.txt" ]; then
            echo "FAIL: Protected file was created when it should have been blocked!"
            cat protected/test-write.txt
            exit 1
          fi
          echo "PASS: Protected file was not created"

          # Verify existing file was not modified
          CONTENT=$(cat protected/existing-file.txt)
          if [ "$CONTENT" != "protected content" ]; then
            echo "FAIL: Protected existing file was modified!"
            exit 1
          fi
          echo "PASS: Existing protected file content unchanged"

          echo ""
          echo "Protected file write correctly blocked"

      - name: E2E Test - Unprotected file write allowed
        shell: bash
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          echo "Testing that unprotected files can be written..."

          cd "${E2E_DIR}"

          # Ask Claude to write to an unprotected file
          # Note: --allowedTools "Write" is needed so Claude can write without interactive permission
          set +e
          OUTPUT=$(claude --print "Write the text 'NEW CONTENT' to the file unprotected/test-write.txt" --max-turns 3 --allowedTools "Write" 2>&1)
          CLAUDE_EXIT=$?
          set -e

          echo "Claude exit code: $CLAUDE_EXIT"
          echo "Claude output:"
          echo "$OUTPUT"
          echo ""

          # Check if Claude failed unexpectedly
          if [ $CLAUDE_EXIT -ne 0 ]; then
            echo "FAIL: Claude exited with code $CLAUDE_EXIT for unprotected file write"
            echo "This should have succeeded - unprotected files should be writable"
            exit 1
          fi

          # The file MUST exist (was allowed and written)
          if [ -f "unprotected/test-write.txt" ]; then
            echo "PASS: Unprotected file write correctly allowed"
            echo "File contents:"
            cat unprotected/test-write.txt
          else
            echo "FAIL: Unprotected file was NOT created"
            echo "Claude output was:"
            echo "$OUTPUT"
            echo ""
            echo "The hook should have allowed this write operation"
            exit 1
          fi

      - name: E2E Test - Direct hook execution test
        if: runner.os != 'Windows'
        shell: bash
        run: |
          echo "Testing hooks directly with simulated Claude Code input..."
          echo ""

          echo "=== Testing protect_directories.py ==="

          PROTECT_OUTPUT=$(echo "{\"tool_name\": \"Edit\", \"tool_input\": {\"file_path\": \"${E2E_DIR}/protected/test.txt\"}}" | python hooks/protect_directories.py)
          echo "protect_directories output:"
          echo "$PROTECT_OUTPUT"
          echo ""

          # Should block (protected directory)
          if echo "$PROTECT_OUTPUT" | grep -q '"decision".*:.*"block"'; then
            echo "PASS: protect_directories returns 'block' decision"
          else
            echo "FAIL: Protected file was not blocked"
            exit 1
          fi

          # Should have a reason explaining why it was blocked
          if echo "$PROTECT_OUTPUT" | grep -q '"reason"'; then
            echo "PASS: Block response includes 'reason' field"
          else
            echo "FAIL: Block response should include 'reason' field"
            exit 1
          fi

          echo ""
          echo "=== Testing protect_directories.py with UNPROTECTED path (no .block) ==="

          UNPROTECT_OUTPUT=$(echo "{\"tool_name\": \"Edit\", \"tool_input\": {\"file_path\": \"${E2E_DIR}/unprotected/test.txt\"}}" | python hooks/protect_directories.py)
          UNPROTECT_EXIT=$?
          echo "protect_directories output for unprotected path:"
          echo "$UNPROTECT_OUTPUT"
          echo "Exit code: $UNPROTECT_EXIT"
          echo ""

          # Should allow (exit 0, no block decision) for unprotected directory
          if [ "$UNPROTECT_EXIT" -eq 0 ] && ! echo "$UNPROTECT_OUTPUT" | grep -q '"decision".*:.*"block"'; then
            echo "PASS: protect_directories allows unprotected path"
          else
            echo "FAIL: Unprotected path should be allowed"
            exit 1
          fi

          echo ""
          echo "=== All direct hook tests passed ==="

      # Note: Direct hook tests are skipped on Windows because Git Bash and Python
      # handle Windows paths differently. The pytest tests provide full coverage.

      - name: E2E Test Summary
        if: always()
        shell: bash
        run: |
          echo "=========================================="
          echo "E2E Test Summary"
          echo "=========================================="
          echo "OS: ${{ matrix.os }}"
          echo ""
          echo "Test scenarios covered:"
          echo "  - Protected file write blocking"
          echo "  - Unprotected file write allowing"
          echo "  - Direct hook execution"
          echo "=========================================="

  version:
    name: Calculate Version
    runs-on: ubuntu-latest
    needs: [changes, test-linux, test-macos, test-windows, lint, e2e]
    if: |
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push' &&
      needs.changes.outputs.should_version == 'true'
    outputs:
      semVer: ${{ steps.gitversion.outputs.semVer }}
      majorMinorPatch: ${{ steps.gitversion.outputs.majorMinorPatch }}
      fullSemVer: ${{ steps.gitversion.outputs.fullSemVer }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Configure Git Safe Directory
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v4.2.0
        with:
          versionSpec: '6.x'

      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v4.2.0
        with:
          configFilePath: GitVersion.yml

      - name: Display Version
        run: |
          echo "SemVer: ${{ steps.gitversion.outputs.semVer }}"
          echo "MajorMinorPatch: ${{ steps.gitversion.outputs.majorMinorPatch }}"
          echo "FullSemVer: ${{ steps.gitversion.outputs.fullSemVer }}"
          echo "Major: ${{ steps.gitversion.outputs.major }}"
          echo "Minor: ${{ steps.gitversion.outputs.minor }}"
          echo "Patch: ${{ steps.gitversion.outputs.patch }}"

  tag:
    name: Create Git Tag
    runs-on: ubuntu-latest
    needs: version
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Update plugin version
        run: |
          python -c "
          import json
          with open('.claude-plugin/plugin.json', 'r') as f:
              data = json.load(f)
          data['version'] = '${{ needs.version.outputs.majorMinorPatch }}'
          with open('.claude-plugin/plugin.json', 'w') as f:
              json.dump(data, f, indent=2)
          "

      - name: Commit and tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .claude-plugin/plugin.json
          git commit -m "Bump version to ${{ needs.version.outputs.majorMinorPatch }}"
          git push origin main
          git tag -a "v${{ needs.version.outputs.majorMinorPatch }}" -m "Release v${{ needs.version.outputs.majorMinorPatch }}"
          git push origin "v${{ needs.version.outputs.majorMinorPatch }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-marketplace:
    name: Update Marketplace
    runs-on: ubuntu-latest
    needs: [version, tag]
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout marketplace repository
        uses: actions/checkout@v6
        with:
          repository: kodroi/block-marketplace
          token: ${{ secrets.MARKETPLACE_TOKEN }}
          path: marketplace

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Update marketplace.json plugin version
        run: |
          cd marketplace
          VERSION="${{ needs.version.outputs.majorMinorPatch }}"
          python -c "
          import json
          with open('.claude-plugin/marketplace.json', 'r') as f:
              data = json.load(f)
          data['plugins'][0]['version'] = '$VERSION'
          with open('.claude-plugin/marketplace.json', 'w') as f:
              json.dump(data, f, indent=2)
          "

      - name: Commit and push
        run: |
          cd marketplace
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .claude-plugin/marketplace.json
          git diff --staged --quiet || (
            git commit -m "Update block plugin to v${{ needs.version.outputs.majorMinorPatch }}"
            git push origin main
          )
