name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      should_version: ${{ steps.filter.outputs.versionable == 'true' || steps.semver.outputs.has_semver == 'true' }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            versionable:
              - 'hooks/**'
              - 'commands/**'
              - 'GitVersion.yml'

      - name: Check for +semver in commit message
        id: semver
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -qE '\+semver:\s*(major|minor|patch|breaking|feature|fix|none|skip)'; then
            echo "has_semver=true" >> $GITHUB_OUTPUT
            echo "Found +semver in commit message"
          else
            echo "has_semver=false" >> $GITHUB_OUTPUT
            echo "No +semver found in commit message"
          fi

  test-linux:
    name: Test on Linux
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov

      - name: Verify Python installation
        run: |
          echo "Python version:"
          python --version
          echo "pytest version:"
          pytest --version

      - name: Run pytest tests
        run: |
          pytest tests/ -v --tb=short

      - name: Test hook directly with sample input
        run: |
          # Create a test directory with protection
          mkdir -p /tmp/test-project
          touch /tmp/test-project/.block

          # Test Edit tool is blocked (check for JSON block decision)
          OUTPUT=$(echo '{"tool_name": "Edit", "tool_input": {"file_path": "/tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' || { echo "Expected block decision for Edit"; exit 1; }
          echo "Edit tool correctly blocked"

          # Test Write tool is blocked
          OUTPUT=$(echo '{"tool_name": "Write", "tool_input": {"file_path": "/tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' || { echo "Expected block decision for Write"; exit 1; }
          echo "Write tool correctly blocked"

          # Test Read tool is allowed (not a modifying operation)
          OUTPUT=$(echo '{"tool_name": "Read", "tool_input": {"file_path": "/tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' && { echo "Read should not be blocked"; exit 1; } || true
          echo "Read tool correctly allowed"

          # Test Bash rm command is blocked
          OUTPUT=$(echo '{"tool_name": "Bash", "tool_input": {"command": "rm /tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' || { echo "Expected block decision for Bash rm"; exit 1; }
          echo "Bash rm correctly blocked"

  test-macos:
    name: Test on macOS
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov

      - name: Verify Python installation
        run: |
          echo "Python version:"
          python --version
          echo "pytest version:"
          pytest --version

      - name: Run pytest tests
        run: |
          pytest tests/ -v --tb=short

  test-windows:
    name: Test on Windows
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov

      - name: Verify Python installation
        run: |
          echo "Python version:"
          python --version
          echo "pytest version:"
          pytest --version

      - name: Run pytest tests
        run: |
          pytest tests/ -v --tb=short

      - name: Test hook directly with sample input (Windows)
        shell: bash
        run: |
          # Create a test directory with protection
          mkdir -p /tmp/test-project
          touch /tmp/test-project/.block

          # Test Edit tool is blocked (check for JSON block decision)
          OUTPUT=$(echo '{"tool_name": "Edit", "tool_input": {"file_path": "/tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' || { echo "Expected block decision for Edit"; exit 1; }
          echo "Edit tool correctly blocked"

          # Test Write tool is blocked
          OUTPUT=$(echo '{"tool_name": "Write", "tool_input": {"file_path": "/tmp/test-project/file.txt"}}' | python hooks/protect_directories.py)
          echo "$OUTPUT" | grep -q '"decision".*"block"' || { echo "Expected block decision for Write"; exit 1; }
          echo "Write tool correctly blocked"

  lint:
    name: Python Linting and Type Checking
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install linting tools
        run: |
          python -m pip install --upgrade pip
          pip install ruff mypy

      - name: Run ruff linter
        run: |
          ruff check hooks/ tests/

      - name: Run mypy type checker
        run: |
          mypy hooks/protect_directories.py --ignore-missing-imports

  e2e:
    name: E2E - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code CLI
        run: npm install -g @anthropic-ai/claude-code

      - name: Verify Claude Code installation
        run: claude --version

      - name: Make scripts executable (Unix)
        if: runner.os != 'Windows'
        run: chmod +x hooks/*.sh hooks/*.py

      - name: Verify hook scripts exist
        shell: bash
        run: |
          echo "Verifying hook scripts exist in: ${GITHUB_WORKSPACE}"

          # Check Python script
          if [ -f "hooks/protect_directories.py" ]; then
            echo "Found: hooks/protect_directories.py"
            ls -la hooks/protect_directories.py
          else
            echo "ERROR: Missing hooks/protect_directories.py"
            exit 1
          fi

          # Check Unix wrapper
          if [ -f "hooks/protect-directories.sh" ]; then
            echo "Found: hooks/protect-directories.sh"
          else
            echo "ERROR: Missing hooks/protect-directories.sh"
            exit 1
          fi

          # Check Windows wrapper
          if [ -f "hooks/protect-directories.cmd" ]; then
            echo "Found: hooks/protect-directories.cmd"
          else
            echo "ERROR: Missing hooks/protect-directories.cmd"
            exit 1
          fi

          echo ""
          echo "All hook scripts found!"

      - name: Create test project directory
        shell: bash
        run: |
          mkdir -p /tmp/e2e-test-project/protected
          mkdir -p /tmp/e2e-test-project/unprotected

          # Create .block file in protected directory
          echo '{}' > /tmp/e2e-test-project/protected/.block

          # Create some test files
          echo "protected content" > /tmp/e2e-test-project/protected/existing-file.txt
          echo "unprotected content" > /tmp/e2e-test-project/unprotected/existing-file.txt

      - name: Configure Claude Code with plugin hooks (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          # Get the absolute path to the plugin root
          PLUGIN_ROOT="${GITHUB_WORKSPACE}"
          PROTECT_PATH="${PLUGIN_ROOT}/hooks/protect-directories.sh"

          echo "Hook path: $PROTECT_PATH"

          # Verify files exist
          if [ ! -f "$PROTECT_PATH" ]; then
            echo "ERROR: protect-directories.sh not found at $PROTECT_PATH"
            exit 1
          fi

          # Create Claude Code settings directory
          mkdir -p ~/.claude

          # Create settings.json with hooks configuration
          cat > ~/.claude/settings.json <<EOF
          {
            "hooks": {
              "PreToolUse": [
                {
                  "matcher": "Edit|Write|NotebookEdit|Bash",
                  "hooks": [
                    {
                      "type": "command",
                      "command": "${PROTECT_PATH}",
                      "timeout": 5000
                    }
                  ]
                }
              ]
            }
          }
          EOF

          echo ""
          echo "Created Claude Code settings:"
          cat ~/.claude/settings.json

      - name: Configure Claude Code with plugin hooks (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          PLUGIN_ROOT="${GITHUB_WORKSPACE}"
          PROTECT_PATH="${PLUGIN_ROOT}/hooks/protect-directories.cmd"

          echo "Hook path (Windows): $PROTECT_PATH"

          # Verify files exist
          if [ ! -f "$PROTECT_PATH" ]; then
            echo "ERROR: protect-directories.cmd not found at $PROTECT_PATH"
            exit 1
          fi

          # Create Claude Code settings directory
          mkdir -p ~/.claude

          # Create settings.json with hooks configuration
          cat > ~/.claude/settings.json <<EOF
          {
            "hooks": {
              "PreToolUse": [
                {
                  "matcher": "Edit|Write|NotebookEdit|Bash",
                  "hooks": [
                    {
                      "type": "command",
                      "command": "${PROTECT_PATH}",
                      "timeout": 5000
                    }
                  ]
                }
              ]
            }
          }
          EOF

          echo ""
          echo "Created Claude Code settings (Windows):"
          cat ~/.claude/settings.json

      - name: E2E Test - Protected file write blocked
        shell: bash
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          echo "Testing that protected files cannot be written..."

          cd /tmp/e2e-test-project

          # Ask Claude to write to a protected file
          OUTPUT=$(claude --print "Write the text 'MODIFIED' to the file protected/test-write.txt" --max-turns 3 --allowedTools "" 2>&1) || true

          echo "Claude output:"
          echo "$OUTPUT"
          echo ""

          # The file should NOT exist (was blocked)
          if [ -f "protected/test-write.txt" ]; then
            echo "FAIL: Protected file was created when it should have been blocked!"
            cat protected/test-write.txt
            exit 1
          fi
          echo "PASS: Protected file was not created"

          # Verify existing file was not modified
          CONTENT=$(cat protected/existing-file.txt)
          if [ "$CONTENT" != "protected content" ]; then
            echo "FAIL: Protected existing file was modified!"
            exit 1
          fi
          echo "PASS: Existing protected file content unchanged"

          echo ""
          echo "Protected file write correctly blocked"

      - name: E2E Test - Unprotected file write allowed
        shell: bash
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          echo "Testing that unprotected files can be written..."

          cd /tmp/e2e-test-project

          # Ask Claude to write to an unprotected file
          OUTPUT=$(claude --print "Write the text 'NEW CONTENT' to the file unprotected/test-write.txt" --max-turns 3 2>&1) || true

          echo "Claude output:"
          echo "$OUTPUT"

          # The file should exist (was allowed)
          if [ -f "unprotected/test-write.txt" ]; then
            echo "Unprotected file write correctly allowed"
            cat unprotected/test-write.txt
          else
            echo "Note: File may not have been created due to Claude's decision, not blocking"
            echo "This is acceptable as long as protected writes ARE blocked"
          fi

      - name: E2E Test - Direct hook execution test
        shell: bash
        run: |
          echo "Testing hooks directly with simulated Claude Code input..."
          echo ""

          echo "=== Testing protect_directories.py ==="

          PROTECT_OUTPUT=$(echo '{"tool_name": "Edit", "tool_input": {"file_path": "/tmp/e2e-test-project/protected/test.txt"}}' | python hooks/protect_directories.py)
          echo "protect_directories output:"
          echo "$PROTECT_OUTPUT"
          echo ""

          # Should block (protected directory)
          if echo "$PROTECT_OUTPUT" | grep -q '"decision".*:.*"block"'; then
            echo "PASS: protect_directories returns 'block' decision"
          else
            echo "FAIL: Protected file was not blocked"
            exit 1
          fi

          # Should have a reason explaining why it was blocked
          if echo "$PROTECT_OUTPUT" | grep -q '"reason"'; then
            echo "PASS: Block response includes 'reason' field"
          else
            echo "FAIL: Block response should include 'reason' field"
            exit 1
          fi

          echo ""
          echo "=== Testing protect_directories.py with UNPROTECTED path (no .block) ==="

          UNPROTECT_OUTPUT=$(echo '{"tool_name": "Edit", "tool_input": {"file_path": "/tmp/e2e-test-project/unprotected/test.txt"}}' | python hooks/protect_directories.py)
          UNPROTECT_EXIT=$?
          echo "protect_directories output for unprotected path:"
          echo "$UNPROTECT_OUTPUT"
          echo "Exit code: $UNPROTECT_EXIT"
          echo ""

          # Should allow (exit 0, no block decision) for unprotected directory
          if [ "$UNPROTECT_EXIT" -eq 0 ] && ! echo "$UNPROTECT_OUTPUT" | grep -q '"decision".*:.*"block"'; then
            echo "PASS: protect_directories allows unprotected path"
          else
            echo "FAIL: Unprotected path should be allowed"
            exit 1
          fi

          echo ""
          echo "=== All direct hook tests passed ==="

      - name: E2E Test Summary
        if: always()
        shell: bash
        run: |
          echo "=========================================="
          echo "E2E Test Summary"
          echo "=========================================="
          echo "OS: ${{ matrix.os }}"
          echo ""
          echo "Test scenarios covered:"
          echo "  - Protected file write blocking"
          echo "  - Unprotected file write allowing"
          echo "  - Direct hook execution"
          echo "=========================================="

  version:
    name: Calculate Version
    runs-on: ubuntu-latest
    needs: [changes, test-linux, test-macos, test-windows, lint, e2e]
    if: |
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push' &&
      needs.changes.outputs.should_version == 'true'
    outputs:
      semVer: ${{ steps.gitversion.outputs.semVer }}
      majorMinorPatch: ${{ steps.gitversion.outputs.majorMinorPatch }}
      fullSemVer: ${{ steps.gitversion.outputs.fullSemVer }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Configure Git Safe Directory
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v4.2.0
        with:
          versionSpec: '6.x'

      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v4.2.0
        with:
          configFilePath: GitVersion.yml

      - name: Display Version
        run: |
          echo "SemVer: ${{ steps.gitversion.outputs.semVer }}"
          echo "MajorMinorPatch: ${{ steps.gitversion.outputs.majorMinorPatch }}"
          echo "FullSemVer: ${{ steps.gitversion.outputs.fullSemVer }}"
          echo "Major: ${{ steps.gitversion.outputs.major }}"
          echo "Minor: ${{ steps.gitversion.outputs.minor }}"
          echo "Patch: ${{ steps.gitversion.outputs.patch }}"

  tag:
    name: Create Git Tag
    runs-on: ubuntu-latest
    needs: version
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Update plugin version
        run: |
          python -c "
          import json
          with open('.claude-plugin/plugin.json', 'r') as f:
              data = json.load(f)
          data['version'] = '${{ needs.version.outputs.majorMinorPatch }}'
          with open('.claude-plugin/plugin.json', 'w') as f:
              json.dump(data, f, indent=2)
          "

      - name: Commit and tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .claude-plugin/plugin.json
          git commit -m "Bump version to ${{ needs.version.outputs.majorMinorPatch }}"
          git push origin main
          git tag -a "v${{ needs.version.outputs.majorMinorPatch }}" -m "Release v${{ needs.version.outputs.majorMinorPatch }}"
          git push origin "v${{ needs.version.outputs.majorMinorPatch }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-marketplace:
    name: Update Marketplace
    runs-on: ubuntu-latest
    needs: [version, tag]
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout marketplace repository
        uses: actions/checkout@v6
        with:
          repository: kodroi/block-marketplace
          token: ${{ secrets.MARKETPLACE_TOKEN }}
          path: marketplace

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Update marketplace.json plugin version
        run: |
          cd marketplace
          VERSION="${{ needs.version.outputs.majorMinorPatch }}"
          python -c "
          import json
          with open('.claude-plugin/marketplace.json', 'r') as f:
              data = json.load(f)
          data['plugins'][0]['version'] = '$VERSION'
          with open('.claude-plugin/marketplace.json', 'w') as f:
              json.dump(data, f, indent=2)
          "

      - name: Commit and push
        run: |
          cd marketplace
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .claude-plugin/marketplace.json
          git diff --staged --quiet || (
            git commit -m "Update block plugin to v${{ needs.version.outputs.majorMinorPatch }}"
            git push origin main
          )
